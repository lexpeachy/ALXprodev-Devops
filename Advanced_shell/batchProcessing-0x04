#!/usr/bin/env python3

import os
import subprocess
import concurrent.futures

POKEMON_LIST = ["bulbasaur", "ivysaur", "venusaur", "charmander", "charmeleon"]
MAX_WORKERS = 3  # Optimal number of parallel requests

def fetch_pokemon(pokemon):
    """Fetch data for a single Pokémon"""
    try:
        subprocess.run(
            [
                "curl",
                "-s",
                "--connect-timeout", "10",
                "--max-time", "30",
                "-o", f"pokemon_data/{pokemon}.json",
                f"https://pokeapi.co/api/v2/pokemon/{pokemon}"
            ],
            check=True
        )
        return (pokemon, True)
    except subprocess.CalledProcessError:
        return (pokemon, False)

def main():
    os.makedirs("pokemon_data", exist_ok=True)
    
    print("Starting parallel Pokémon data fetch...")
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        # Submit all fetch operations
        future_to_pokemon = {
            executor.submit(fetch_pokemon, pokemon): pokemon
            for pokemon in POKEMON_LIST
        }
        
        # Process results as they complete
        success_count = 0
        for future in concurrent.futures.as_completed(future_to_pokemon):
            pokemon, success = future.result()
            if success:
                print(f"✅ Successfully fetched {pokemon}")
                success_count += 1
            else:
                print(f"❌ Failed to fetch {pokemon}")
    
    print(f"\nFetch complete. Success: {success_count}/{len(POKEMON_LIST)}")

if __name__ == "__main__":
    main()
